#!/bin/bash
set -x
set -e
URL=$1
RESULT_PATH=/srv/guix_result

URL_PROTOCOL="https://"
URL_WITHOUT_PROTOCOL=$(echo "$URL" | sed "s#^$URL_PROTOCOL##")
URL_DOMAIN=$(echo "$URL_WITHOUT_PROTOCOL" | cut -d '/' -f 1)
URL_PATH_PARTS=$(echo "$URL_WITHOUT_PROTOCOL" | cut -d '/' -f 2-)
URL_REPO_CORE=$(echo "$URL_PATH_PARTS" | cut -d '/' -f 1,2 | sed 's#/$##')
REPO=$(echo $URL_REPO_CORE | cut -d '/' -f 2 | sed 's/\.git$//')
REPO_URL="${URL_PROTOCOL}${URL_DOMAIN}/${URL_REPO_CORE}"

if [[ "$URL" =~ /(pull)/([0-9]+) ]]; then
    echo "类型: ${BASH_REMATCH[1]}"
    echo "ID: ${BASH_REMATCH[2]}"
    fetch_ref="pull/${BASH_REMATCH[2]}/head"
elif [[ "$URL" =~ /(commit)/([0-9a-f]+) ]]; then
    echo "类型: ${BASH_REMATCH[1]}"
    echo "哈希值: ${BASH_REMATCH[2]}"
    fetch_ref="${BASH_REMATCH[2]}"
else
    echo "pull/commit未匹配到有效信息"
    exit 1
fi
if [[ "${REPO}" == "rvck" ]];then
    kernel_config="defconfig"
elif [[ "${REPO}" == "rvck-olk" ]];then
    kernel_config="openeuler_defconfig"
else
    echo "kernel_config未匹配到有效信息"
    exit 1
fi


TEMP_DIR=$(mktemp -d)
pushd ${TEMP_DIR}

git init .
git config user.email rvci@isrc.iscas.ac.cn
git config user.name rvci
git remote add origin "${REPO_URL}"
git fetch origin "$fetch_ref":"$fetch_ref" --depth=1 --progress
git checkout $fetch_ref

git_commit=$(git rev-parse HEAD)
work_path=$(pwd)
popd

# set guix version with commit, first download from substitute-urls, if substitute-urls download failed, then local build with guix source git repo
cat > channels-lock.scm <<EOF
(list
 (channel
  (name 'rvci)
  (url "https://git.oerv.ac.cn/Z572/guix-rvci-channel")
  (branch "master"))
 (channel
  (name 'guix)
  (url "https://git.oerv.ac.cn/wangliu-iscas/guix-mirror.git")
  (branch "master")
  (commit
   "dd63521f33b34cf7620d9f98573515805b70e3cf")
  (introduction
   (make-channel-introduction
    "9edb3f66fd807b096b48283debdcddccfea34bad"
    (openpgp-fingerprint
     "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))))
EOF
cat channels-lock.scm

# calculate the kernel repo hash based on commitid
guix_command_hash=$(/entry-point.sh guix time-machine --substitute-urls=https://mirror.sjtu.edu.cn/guix -C channels-lock.scm -- download --git file://${work_path}  --commit=${git_commit})
repo_hash=$(echo ${guix_command_hash} | awk -F' ' '{print $2}')
if [ -z "${repo_hash}" ];then
    echo "hash command error"
    cat > guix-kernel-build.scm <<EOF
(use-modules (oerv packages rvck))
(make-linux-rvck
  #:name "linux-rvck"
  #:defconfig "${kernel_config}"
  #:commit "${git_commit}"
  #:url "file://${work_path}"
EOF
else
    cat > guix-kernel-build.scm <<EOF
(use-modules (oerv packages rvck))
(make-linux-rvck
  #:name "linux-rvck"
  #:defconfig "${kernel_config}"
  #:commit "${git_commit}"
  #:url "file://${work_path}"
  #:hash "${repo_hash}")
EOF
fi

cat guix-kernel-build.scm

# build kernel
/entry-point.sh guix time-machine --substitute-urls=https://mirror.sjtu.edu.cn/guix -C channels-lock.scm -- build -f guix-kernel-build.scm --substitute-urls=https://mirror.sjtu.edu.cn/guix --target=riscv64-linux-gnu -r ${TEMP_DIR}/${git_commit} 
if [ -L ${TEMP_DIR}/${git_commit} ] && [ -d ${TEMP_DIR}/${git_commit} ];then
    echo "Kernel result dir: ${TEMP_DIR}/${git_commit}"
    if [ -f ${TEMP_DIR}/${git_commit}/Image ];then
        echo "Kernel result file: ${TEMP_DIR}/${git_commit}/Image"
    else
        echo "Error: ${TEMP_DIR}/${git_commit}/Image not found"
        exit 1 
    fi
else
    echo "Error: ${TEMP_DIR}/${git_commit} not found"
    exit 1
fi
if [ -d ${RESULT_PATH}/${git_commit} ];then
    rm -fr ${RESULT_PATH}/${git_commit}
fi

# copy result from guix result link
mkdir -p ${RESULT_PATH}/${git_commit}
rsync -avP ${TEMP_DIR}/${git_commit}/ ${RESULT_PATH}/${git_commit}/

# create modules archive
module_path_name=$(ls ${RESULT_PATH}/${git_commit}/lib/modules/)
module_dir_name=$(basename "$module_path_name")
depmod -b ${RESULT_PATH}/${git_commit} "$module_dir_name"
tar -cvzf  ${RESULT_PATH}/${git_commit}/"$module_dir_name".tgz -C ${RESULT_PATH}/${git_commit}/lib/modules/ "$module_dir_name"

set +e

# create initramfs
initramfs_chroot=$(mktemp -d)
mkdir -p ${initramfs_chroot}/dev ${initramfs_chroot}/proc ${initramfs_chroot}/sys ${initramfs_chroot}/run
mount --bind /dev ${initramfs_chroot}/dev
mount --bind /dev/pts ${initramfs_chroot}/dev/pts
mount --bind /dev/shm ${initramfs_chroot}/dev/shm
mount --bind /run ${initramfs_chroot}/run
mount -t proc proc ${initramfs_chroot}/proc
mount -t sysfs sys ${initramfs_chroot}/sys

dnf group install -y "Minimal Install" --forcearch riscv64 --installroot ${initramfs_chroot}
dnf install -y dracut --forcearch riscv64 --installroot ${initramfs_chroot} 
cp -r ${RESULT_PATH}/${git_commit}/lib/modules/${module_dir_name} ${initramfs_chroot}/lib/modules/
chroot ${initramfs_chroot} /bin/bash -c "dracut /root/initramfs.img --no-hostonly --add "nfs network base" --add-drivers "k1-emac" --kver ${module_dir_name} && md5sum /root/initramfs.img > /root/initramfs.img.md5sum"
md5sum ${RESULT_PATH}/${git_commit}/Image > ${RESULT_PATH}/${git_commit}/Image.md5sum
cp ${initramfs_chroot}/root/initramfs.img* ${RESULT_PATH}/${git_commit}/
chmod 0644 ${RESULT_PATH}/${git_commit}/initramfs.img

# Unmount filesystems if they exist
if [ -d "${initramfs_chroot}/dev/pts" ]; then
    umount ${initramfs_chroot}/dev/pts 2>/dev/null || true
fi
if [ -d "${initramfs_chroot}/dev/shm" ]; then
    umount ${initramfs_chroot}/dev/shm 2>/dev/null || true
fi
if [ -d "${initramfs_chroot}/dev" ]; then
    umount ${initramfs_chroot}/dev 2>/dev/null || true
fi
if [ -d "${initramfs_chroot}/proc" ]; then
    umount ${initramfs_chroot}/proc 2>/dev/null || true
fi
if [ -d "${initramfs_chroot}/sys" ]; then
    umount ${initramfs_chroot}/sys 2>/dev/null || true
fi
if [ -d "${initramfs_chroot}/run" ]; then
    umount ${initramfs_chroot}/run 2>/dev/null || true
fi

ls ${RESULT_PATH}/${git_commit}
